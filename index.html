<html>

<head>
    <title>Timer</title>
<style>
html {
  scroll-behavior: smooth;
}

div.exercise {
  font-family: Arial, Helvetica, sans-serif;
  font-size: 30px;
  transition-property: font-size;
  transition-duration: 0.3s;
}

div.exercise.current {
  font-weight: bold;
  font-size: 40px;
  transition-property: font-size;
  transition-duration: 0.3s;
}

div.separator {
  height: 100;
}

div.set {
    margin-bottom: 60px;
}

#exercises {
  margin-top: 30px;
}

#action_label {
  font-family: Arial, Helvetica, sans-serif;
  font-size: 40px;
  text-align: center;
}

#work_label {
  color: green;
}

#rest_label {
  color: red;
}

#placeholder-for-scroll-top { height: 50%; }
#placeholder-for-scroll-bottom { height: 100%; }

div.set-info {
  background-color: white;
  font-family: Arial, Helvetica, sans-serif;
  font-size: medium;
  position: sticky;
  top: 0;
  padding-top: 20px;
  padding-bottom: 20px;
  border-bottom: 1px solid black;
}

div.set-title {
    font-size: 40px;
}

#timer-container {
  font-family: Arial, Helvetica, sans-serif;
  left: 0;
  width: 100%;
  position: fixed;
  margin-right: 30px;
  background-color: white;
  border-bottom: 1px;
  border-color: black;
  box-shadow: rgb(0 0 0 / 20%) 0px 0px 15px;
}

#timer-container-inner {
  margin-right: 8px;
  margin-left: 8px;
}

#timer {
  width: auto;
  text-align: center;
  font-family: monospace;
  font-size: 100px;
  background-color: #E7E7E7;
  color: black;
}

#timer.work {
  background-color: #4CAF50;
  color: white;
}

#timer.rest {
  background-color: crimson;
  color: white;
}

#timer.inactive {
  background-color: #E7E7E7;
  color: black;
}

#start_container {
  text-align: center;
  width: auto;
  margin-bottom: 10px;
}

#start_button {
  width: 100%;
  
  background-color: #E7E7E7;
  color: white;
  color: black;
  text-decoration: none;
  border: none;
  margin-top: 2px;
  padding: 10px;
  font-size: 32px;
  display: inline-block;
  font-family: Arial, Helvetica, sans-serif;
  text-transform: uppercase;
}
</style>
</head>

<body>

<!-- <a href="#" onclick="play()">Play</a>
<a href="#" onclick="define()">Define</a> -->
<div style="display: none;">
    Sets: <span id='num_sets'></span>
    Exercises: <span id='num_exercises'></span>
</div>
<div style="display: none;">
    Set: <span id='current_set'></span>
    Exercise: <span id='current_exercise'></span>
</div>
<div style="display: none;">
Work: <span id='current_work'></span>
Rest: <span id='current_rest'></span>
</div>

</div>
<div class='container'>
    <div class='exercise_area'>
        <div id='play_area'>
            <div id='placeholder-for-scroll-top'></div>
            <div id='exercises' onclick="define()"></div>
            <div id='placeholder-for-scroll-bottom'></div>
        </div>
    
        <div style="display:none"  id='define_area'>
            <span id=>Exercises:</span>
            <div>
                <textarea id='exercises_def' rows='30' cols='40'
                onchange='reload()'
                onblur='play()'>
        5/3
        Exercise 1
        Exercise 2
        Exercise 3
        
        6/4
        Ex 1
        Ex 2
                </textarea>
            </div>
        </div>
    </div>
</div>
<div id='timer-container'>
    <div id='timer-container-inner'>
        <div id='action_label'>
            <div id='work_label'>
                WORK
            </div>
            <div id='rest_label'>
                REST
            </div>
            <div id='ready_label'>
                READY
            </div>
            <div id='paused_label'>
                PAUSED
            </div>
        </div>
        <div id='timer'>
            <span id='mins'></span>:<span id='secs'></span>
        </div>
        <div id='start_container'>
            <button onclick="start()" id='start_button'>start</button>
        </div>
    </div>
</div>




<script>
const id = function(id) { return document.getElementById(id); };

const audioCtx = new (window.AudioContext || window.webkitAudioContext)();

const NOT_STARTED = 1;
const PLAYING = 2;
const PAUSED = 3;
let state = NOT_STARTED;
let intervalId = null;

let isWork = true;
let work = 2;
let rest = 2;
let currentSetIndex = 0;
let currentSetExercise = 0;
let currentExercise = 0;
let isDefineMode = false;
let sets = [];

let remaining = work;

window.onresize = updateUi;

const storedExercises = localStorage.getItem('exercises');
if (storedExercises != null && storedExercises.trim() != "") {
    id('exercises_def').value = storedExercises;
}

reload();

function start() {
    shortBeep();
    switch(state) {
        case NOT_STARTED:
            state = PLAYING;
            break;
        case PLAYING:
            state = PAUSED; 
            break;
        case PAUSED:
            state = PLAYING;
            break;
    }

    updateUi();
    if(intervalId) {
        clearInterval(intervalId);
        intervalId = null;
    }
    if (state == PLAYING) {
        intervalId = setInterval(
            function() {
                updateSecond();
            }, 1000
        );
    }
}

function updateSecond() {
    if(remaining > 0) {
        remaining--;
        if(remaining == 0) {
            longBeep();
            if(isWork) {
                if(currentSetExercise < sets[currentSetIndex].numExercises - 1) {
                    // This is not the last exercise. Move on to the rest period.
                    isWork = false;
                    remaining = rest;
                } else {
                    // We just finished work for the last exercise in the set.
                    // Move on to the next set, or back to the first set.
                    currentSetExercise = 0;
                    if(currentSetIndex == sets.length - 1) {
                        currentSetIndex = 0;
                    } else {
                        currentSetIndex++;
                    }
                    // Stop the timer.
                    clearInterval(intervalId);
                    intervalId = null;
                    state = NOT_STARTED;
                    work = sets[currentSetIndex].work;
                    rest = sets[currentSetIndex].rest;
                    remaining = work;
                }
            } else {
                // Just finished rest period. Move on to the next exercise in the set.
                isWork = true;
                remaining = work;
                currentExercise++;
                currentSetExercise++;
            }
        }
    } 
    updateUi();
}

function play() {
    isDefineMode = false;
    const exercisesString = id("exercises_def").value;
    localStorage.setItem('exercises', exercisesString);
    updateUi();
}

function define() {
    isDefineMode = true;
    updateUi();
    id('exercises_def').focus();
}

function updateRemainingTime() {
   const mins = Math.floor(remaining / 60);
   const secs = remaining % 60;
   id("mins").innerText = mins.toString().padStart(2, "0");
   id("secs").innerText = secs.toString().padStart(2, "0");
}

function updateUi() {
    const timer = id('timer');
    id("ready_label").style.display = "none";
    id("work_label").style.display = "none";
    id("rest_label").style.display = "none";
    id("paused_label").style.display = "none";
    switch(state) {
        case NOT_STARTED:
            id('start_button').innerText = 'start';
            timer.classList.remove('rest', 'work')
            timer.classList.add('inactive');
            id("ready_label").style.display = "block";
            break;
        case PLAYING:
            id("ready_label").style.display = "none";
            if(id('start_button').innerText != 'pause') {
                id('start_button').innerText = 'pause';
            }
            if(isWork) {
                timer.classList.remove('rest', 'inactive');
                timer.classList.add('work');
                id("work_label").style.display = "block";
            } else {
                timer.classList.remove('work', 'inactive');
                timer.classList.add('rest');
                id("rest_label").style.display = "block";
            }
            break;
        case PAUSED:
            id('start_button').innerText = 'resume';
            timer.classList.remove('rest', 'work')
            timer.classList.add('inactive');
            id("paused_label").style.display = "block";
            break;
    }
    updateRemainingTime();
    id('play_area').style.display = isDefineMode ? "none" : "block";
    id('timer-container').style.display = isDefineMode ? "none" : "block";
    id('define_area').style.display = isDefineMode ? "block" : "none";
    id("current_work").innerText = work;
    id("current_rest").innerText = rest;
    id('num_sets').innerText = sets.length;
    id('num_exercises').innerText = 
        sets.reduce((a, c) => a + c.numExercises, 0);
    id('current_set').innerText = currentSetIndex;
    id('current_exercise').innerText = currentSetExercise;
    const timerContainer = id('timer-container');
    const actionLabel = id('action_label');
    timerContainer.style.top = 0;


    // Give a selected style to the current exercise.
    const exercisesContainer = id("exercises");
    const previouslySelected = document.querySelector('div.exercise.current');
    const currentExerciseElement = id('s' + currentSetIndex + 'e' + currentSetExercise);
    if (previouslySelected != currentExerciseElement) {
        if (previouslySelected != null) {
            previouslySelected.classList.remove('current');
        }
        if (currentExerciseElement != null) {
            currentExerciseElement.classList.add("current");
            // Scroll to the center of the current exercise.
            const offsetTop = currentExerciseElement.getBoundingClientRect().top + document.body.scrollTop;
            const windowHeight = window.innerHeight;
            window.scrollTo(0, offsetTop - windowHeight / 2 + currentExerciseElement.offsetHeight / 2);
        }
    }

    const timerHeight = id('timer-container').offsetHeight;
    document.querySelectorAll('.set-info').forEach(t => t.style.top = timerHeight);
}

function updateExercisesUi() {
    let exercisesContainer = id("exercises");
    // Clear all exercies
    while (exercisesContainer.firstChild) {
        exercisesContainer.removeChild(exercisesContainer.lastChild);
    }
    for (let setIndex = 0; setIndex < sets.length; setIndex++) {
        const set = sets[setIndex];
        const setDiv = document.createElement("div");
        exercisesContainer.appendChild(setDiv);
        setDiv.classList.add('set');
        const setInfo = document.createElement("div");
        setDiv.appendChild(setInfo);
        setInfo.classList.add('set-info');
        const setTitle = document.createElement("div");
        setInfo.appendChild(setTitle);
        setTitle.classList.add('set-title')
        setTitle.innerText = set.title;
        const setTimeLabel = document.createElement("div");
        setInfo.appendChild(setTimeLabel);
        setTimeLabel.innerText = 'Work: ' + set.work + ', rest: ' + set.rest;
        
        for(let exerciseIndex = 0; exerciseIndex < set.exercises.length; exerciseIndex++) {
            const exerciseDiv = document.createElement("div");
            setDiv.appendChild(exerciseDiv);
            exerciseDiv.id = 's' + setIndex + 'e' + exerciseIndex;
            exerciseDiv.classList.add('exercise');
            const textNode = document.createTextNode(set.exercises[exerciseIndex]);
            exerciseDiv.appendChild(textNode);
        }
    }
}

function reload() {
    let exercisesString = document.getElementById("exercises_def").value;
    exercisesString = exercisesString.trim();
    let lines = exercisesString.split("\n");
    const timeSpecRegEx = /^(\d+)\/(\d+)$/;
    let setIndex = 0;
    // New lines are the set separator. Initialize sawNewLine to true so that we always begin with
    // a new set.
    sets = [];
    sets.push({numExercises: 0, exercises: []});
    for(let i = 0; i < lines.length; i++) {
        const line = lines[i].trim();
        if(sets[setIndex].exercises.length == 0) {
            if(line == "") {
                // It's not a new set because we don't have any exercises in the current set yet.
                // Skip this new line.
                continue;
            }
        }
        // If starts with '#' and we don't have any exercises yet and the title hasn't been 
        // set yet.
        if(line.startsWith('#') && sets[setIndex].title === undefined && 
            sets[setIndex].exercises.length == 0) {
            sets[setIndex].title = line.substring(1);
            continue;
        }

        // If we don't have any exercises yet and the work/reset time hasn't been set yet.
        if(sets[setIndex].exercises.length == 0 && sets[setIndex].work === undefined) {
            // Check for time spec
            // Initialize work/rest time for new set.
            const match = line.match(timeSpecRegEx);
            if(match) {
                sets[setIndex].work = match[1];
                sets[setIndex].rest = match[2];
                continue;
            }
        }

        if(line.trim() == "") {
            // const setSeparator = document.createElement("div");
            // setSeparator.classList.add('separator');
            // exercisesContainer.appendChild(setSeparator);
            sets.push({numExercises: 0, exercises: []});
            setIndex++;
            continue;
        }

        // If we're here, the line is an exercise definition
        // If no work/rest time is set now, set it to the previous work/rest time
        if(sets[setIndex].work === undefined) {
            sets[setIndex].work = work;
        }
        if(sets[setIndex].rest === undefined) {
            sets[setIndex].rest = rest;
        }
        // If no title is set, use the default title
        if(sets[setIndex].title === undefined) {
            sets[setIndex].title = `Set ${setIndex + 1}`;
        }

        sets[sets.length - 1].numExercises++;
        sets[sets.length - 1].exercises.push(line);
    }
    // TODO: Make sure currentSetIndex is within bounds.:w
    work = sets[currentSetIndex].work;
    rest = sets[currentSetIndex].rest;
    remaining = work;

    updateExercisesUi();
    updateUi();
}

function shortBeep() {
    beep(100);
}

function longBeep() {
    beep(1000);
}

function beep(duration) {
    const oscillator = audioCtx.createOscillator();
    const gainNode = audioCtx.createGain();

    oscillator.connect(gainNode);
    gainNode.connect(audioCtx.destination);

    gainNode.gain.value = 0.7;
    oscillator.frequency.value = 490;
    oscillator.type = 'triangle';

    oscillator.start();

    setTimeout(
        function () {
            gainNode.gain.exponentialRampToValueAtTime(
                0.00001, audioCtx.currentTime + 0.4
            )
            // oscillator.stop();
        },
        duration
    );
};
    
</script>
</body>
